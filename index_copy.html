<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kannada Baruthe, Boss</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#34D399"/>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .heatmap-day { transition: all 0.2s ease-in-out; }
        .heatmap-day:hover { transform: scale(1.2); }
        .recording { animation: pulse 1.5s infinite; }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .correct-answer { background-color: #A7F3D0 !important; }
        .incorrect-answer { background-color: #FECACA !important; }
        .toggle-checkbox:checked {
            right: 0;
            border-color: #10B981;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #10B981;
        }
        .locked-game {
            opacity: 0.5;
            cursor: not-allowed !important;
            pointer-events: none;
        }
        .lock-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .locked-game-container:hover .lock-message {
            opacity: 1;
        }
        
        /* Responsive canvas fixes */
        #flashcard-canvas, #game-canvas {
            max-width: 100%;
            height: auto;
            min-height: 200px;
        }
        
        @media (max-width: 768px) {
            #flashcard-canvas, #game-canvas {
                height: 250px;
            }
            .grid-cols-2, .grid-cols-4 {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
            .md\:grid-cols-3 {
                grid-template-columns: repeat(1, minmax(0, 1fr));
            }
        }
    </style>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-emerald-50 text-gray-800">

    <!-- Loading Indicator -->
    <div id="loading-indicator" class="fixed inset-0 bg-emerald-50 flex justify-center items-center z-50">
        <div class="text-center">
            <h1 class="text-3xl font-bold text-emerald-700">Kannada Baruthe, Boss</h1>
            <p class="mt-2 text-lg text-gray-600">Loading...</p>
        </div>
    </div>

    <div id="app" class="max-w-4xl mx-auto p-4">
        <!-- App Header -->
        <header id="app-header" class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4">
            <h1 class="text-2xl sm:text-3xl font-bold text-emerald-700 text-center sm:text-left">Kannada Baruthe, Boss</h1>
            <div class="flex items-center space-x-4">
                <div id="user-profile" class="flex items-center space-x-2 cursor-pointer">
                    <span id="username-display" class="font-semibold">Cara</span>
                    <input type="file" id="profile-pic-input" class="hidden" accept="image/*">
                    <img id="profile-pic" src="https://placehold.co/40x40/34D399/FFFFFF?text=C" class="rounded-full w-10 h-10 object-cover" alt="Profile Picture">
                </div>
                <button id="author-mode-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg">Author</button>
            </div>
        </header>

        <!-- Main Content Area -->
        <main id="main-content">
            <!-- Dashboard View -->
            <div id="dashboard-view">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div class="bg-white p-4 rounded-xl shadow-md text-center">
                        <h3 class="font-bold text-lg">Streak</h3>
                        <p class="text-3xl text-emerald-500"><span id="streak-days">0</span> Days</p>
                    </div>
                    <div class="bg-white p-4 rounded-xl shadow-md text-center">
                        <h3 class="font-bold text-lg">Words Learned</h3>
                        <p class="text-3xl text-emerald-500" id="words-learned">0</p>
                    </div>
                    <div class="bg-white p-4 rounded-xl shadow-md text-center">
                        <h3 class="font-bold text-lg">Accuracy</h3>
                        <p class="text-3xl text-emerald-500" id="accuracy-percent">0%</p>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-xl shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Modules</h2>
                    <div id="modules-grid" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div>
                </div>

                <div class="bg-white p-6 rounded-xl shadow-md mt-6">
                    <h2 class="text-2xl font-bold mb-4">Mini-Games</h2>
                    <div id="minigames-grid" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <div class="locked-game-container relative">
                            <button id="speed-match-btn" class="bg-teal-100 p-4 rounded-xl shadow-md text-center cursor-pointer hover:bg-teal-200 transition w-full">
                                <div class="text-4xl mb-2">‚è±Ô∏è</div>
                                <h3 class="font-bold">Speed Match</h3>
                            </button>
                            <div class="lock-message">Learn 20 words to unlock games</div>
                        </div>
                        <div class="locked-game-container relative">
                            <button id="memory-grid-btn" class="bg-amber-100 p-4 rounded-xl shadow-md text-center cursor-pointer hover:bg-amber-200 transition w-full">
                                <div class="text-4xl mb-2">üß†</div>
                                <h3 class="font-bold">Memory Grid</h3>
                            </button>
                            <div class="lock-message">Learn 20 words to unlock games</div>
                        </div>
                        <div class="locked-game-container relative">
                            <button id="listen-tap-btn" class="bg-pink-100 p-4 rounded-xl shadow-md text-center cursor-pointer hover:bg-pink-200 transition w-full">
                                <div class="text-4xl mb-2">üéß</div>
                                <h3 class="font-bold">Listen & Tap</h3>
                            </button>
                            <div class="lock-message">Learn 20 words to unlock games</div>
                        </div>
                        <div class="locked-game-container relative">
                            <button id="sentence-builder-btn" class="bg-indigo-100 p-4 rounded-xl shadow-md text-center cursor-pointer hover:bg-indigo-200 transition w-full">
                                <div class="text-4xl mb-2">üèóÔ∏è</div>
                                <h3 class="font-bold">Sentence Builder</h3>
                            </button>
                            <div class="lock-message">Learn 20 words to unlock games</div>
                        </div>
                        <div class="locked-game-container relative">
                            <button id="fill-blanks-btn" class="bg-blue-100 p-4 rounded-xl shadow-md text-center cursor-pointer hover:bg-blue-200 transition w-full">
                                <div class="text-4xl mb-2">‚úçÔ∏è</div>
                                <h3 class="font-bold">Fill in the Blanks</h3>
                            </button>
                            <div class="lock-message">Learn 20 words to unlock games</div>
                        </div>
                        <button id="trivia-game-btn" class="bg-purple-100 p-4 rounded-xl shadow-md text-center cursor-pointer hover:bg-purple-200 transition">
                            <div class="text-4xl mb-2">üåç</div>
                            <h3 class="font-bold">Trivia</h3>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Lesson View -->
            <div id="lesson-view" class="hidden">
                <div id="focus-mode-header" class="flex justify-between items-center mb-4">
                     <h2 id="lesson-title" class="text-2xl font-bold"></h2>
                     <button id="exit-lesson-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Exit</button>
                </div>
                 <!-- Activity: Flashcard -->
                <div id="flashcard-activity" class="hidden bg-white p-6 rounded-xl shadow-md">
                     <canvas id="flashcard-canvas" class="w-full h-64 rounded-lg bg-gray-100 cursor-pointer"></canvas>
                     <div class="flex justify-center mt-4">
                        <button id="replay-audio-btn" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg mr-4">üîä Replay</button>
                     </div>
                     <div class="flex justify-around mt-4">
                        <button id="flashcard-wrong" class="bg-red-500 text-white font-bold py-3 px-6 rounded-lg text-lg">Again</button>
                        <button id="flashcard-right" class="bg-green-500 text-white font-bold py-3 px-6 rounded-lg text-lg">Got it!</button>
                     </div>
                </div>
            </div>
            
            <!-- Game View -->
            <div id="game-view" class="hidden">
                 <div class="flex justify-between items-center mb-4">
                    <h2 id="game-title" class="text-2xl font-bold"></h2>
                    <button id="exit-game-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Exit Game</button>
                </div>
                <div id="game-container" class="bg-white p-4 rounded-xl shadow-md">
                    <!-- Game content will be dynamically inserted here -->
                </div>
            </div>

            <!-- Author Mode View -->
            <div id="author-mode-view" class="hidden bg-white p-6 rounded-xl shadow-md"></div>
        </main>
    </div>

    <!-- All Modals -->
    <div id="passcode-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50"></div>
    <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50"></div>
    <div id="confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50"></div>
    <div id="prompt-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50"></div>
    <div id="trivia-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50"></div>


    <script type="module">
        // --- FIREBASE SDKs ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getFirestore, collection, doc, getDoc, getDocs, setDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-storage.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
        apiKey: "AIzaSyAHGI5U_EDb1lYNt-uPS2dkRaNeyaUX-oI",
        authDomain: "kannada-app-audio-e6901.firebaseapp.com",
        projectId: "kannada-app-audio-e6901",
        storageBucket: "kannada-app-audio-e6901.firebasestorage.app",
        messagingSenderId: "891878140337",
        appId: "1:891878140337:web:8968ebb24ca661aa58f590"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const firestoreDB = getFirestore(app);
        const storage = getStorage(app);

        // --- GOOGLE CLOUD TTS CONFIG ---
        const GOOGLE_API_KEY = "AIzaSyASuitUOpDtMmaC-5YyWG2AjN5VGkOr-IM";

        // --- SERVICE WORKER ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(reg => console.log('ServiceWorker registration successful'))
                    .catch(err => console.log('ServiceWorker registration failed: ', err));
            });
        }

        // --- AUDIO MANAGEMENT (IMPROVED) ---
        let currentAudio = null;
        let audioQueue = [];
        let isAudioPlaying = false;
        let audioPromises = new Set();

        function stopCurrentAudio() {
            // Cancel any ongoing audio promises
            audioPromises.forEach(promise => {
                if (promise.audio && typeof promise.audio.pause === 'function') {
                    promise.audio.pause();
                    promise.audio.currentTime = 0;
                }
            });
            audioPromises.clear();

            // Stop HTML5 audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }

            // Stop speech synthesis
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            // Clear audio queue
            audioQueue = [];
            isAudioPlaying = false;
        }

        // --- DATABASE (IMPROVED TRANSACTION HANDLING) ---
        const DB_NAME = 'KannadaBarutheBossDB_Progress';
        const DB_VERSION = 1;
        let db;
        let transactionQueue = [];
        let isProcessingQueue = false;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = e => reject("DB error: " + e.target.errorCode);
                request.onupgradeneeded = e => {
                    db = e.target.result;
                    if (!db.objectStoreNames.contains('userData')) db.createObjectStore('userData', { keyPath: 'key' });
                    if (!db.objectStoreNames.contains('srs')) db.createObjectStore('srs', { keyPath: 'phraseId' });
                    if (!db.objectStoreNames.contains('progressLog')) db.createObjectStore('progressLog', { keyPath: 'date' });
                    if (!db.objectStoreNames.contains('cardTracking')) db.createObjectStore('cardTracking', { keyPath: 'phraseId' });
                    if (!db.objectStoreNames.contains('profilePictures')) db.createObjectStore('profilePictures', { keyPath: 'id' });
                };
                request.onsuccess = e => {
                    db = e.target.result;
                    console.log("Progress DB initialized.");
                    resolve(db);
                };
            });
        }

        async function processTransactionQueue() {
            if (isProcessingQueue || transactionQueue.length === 0) return;
            
            isProcessingQueue = true;
            
            while (transactionQueue.length > 0) {
                const { storeName, data, resolve, reject } = transactionQueue.shift();
                
                try {
                    const transaction = db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data);
                    
                    await new Promise((res, rej) => {
                        transaction.oncomplete = () => res();
                        transaction.onerror = (event) => {
                            console.error(`Transaction error on store ${storeName}:`, event.target.error);
                            rej(event.target.error);
                        };
                    });
                    
                    resolve();
                } catch (error) {
                    reject(error);
                }
                
                // Small delay to prevent database locks
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            isProcessingQueue = false;
        }

        function addOrUpdate(storeName, data) {
            return new Promise((resolve, reject) => {
                transactionQueue.push({ storeName, data, resolve, reject });
                processTransactionQueue();
            });
        }

        async function clearStore(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                store.clear();
                transaction.oncomplete = () => resolve();
                transaction.onerror = (event) => {
                    console.error(`Transaction error on store ${storeName}:`, event.target.error);
                    reject("DB Error: " + event.target.error);
                };
            });
        }
        
        function getData(storeName, key) { 
            return new Promise((resolve, reject) => { 
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result); 
                request.onerror = e => {
                    console.error(`Get data error on store ${storeName}:`, e.target.error);
                    reject("DB Error: " + e.target.error);
                };
            }); 
        }
        
        function getAllData(storeName) { 
            return new Promise((resolve, reject) => { 
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result); 
                request.onerror = e => {
                    console.error(`Get all data error on store ${storeName}:`, e.target.error);
                    reject("DB Error: " + e.target.error);
                };
            }); 
        }

        // --- SEED DATA & CONFIG ---
        const moduleOrder = ["greetings", "numbers", "directions", "eating", "shopping", "home", "smalltalk", "family"];
        const seedModules = [
            {"id":"greetings","title":"Greetings & Introductions","icon":"üëã","phrases":[{"id":1,"en":"Hello","kn":"Namaskara","translit":"na-mas-ka-ra"}]},
            {"id":"numbers","title":"Numbers & Time","icon":"üî¢","phrases":[{"id":51,"en":"One","kn":"Ondu","translit":"on-du"}]},
            {"id":"directions","title":"Directions & Transport","icon":"üöÉ","phrases":[{"id":101,"en":"Where is...?","kn":"... ellide?","translit":"el-li-de"}]},
            {"id":"eating","title":"Eating Out","icon":"üçΩÔ∏è","phrases":[{"id":151,"en":"Restaurant","kn":"Upahara gruha","translit":"u-pa-haa-ra gru-ha"}]},
            {"id":"shopping","title":"Shopping & Money","icon":"üõçÔ∏è","phrases":[{"id":201,"en":"How much is this?","kn":"Idara bele eshtu?","translit":"i-da-ra be-le esh-tu"}]},
            {"id":"home","title":"At Home & Chores","icon":"üè†","phrases":[{"id":251,"en":"House","kn":"Mane","translit":"ma-ne"}]},
            {"id":"smalltalk","title":"Social Small Talk","icon":"üí¨","phrases":[{"id":301,"en":"How was your day?","kn":"Nimma dina hegittu?","translit":"nim-ma di-na he-git-tu"}]},
            {"id":"family","title":"Family & Relationships","icon":"üë®‚Äçüë©‚Äçüëß‚Äçüë¶","phrases":[{"id":351,"en":"Family","kn":"Kutumba","translit":"ku-tum-ba"}]}
        ];
        
        async function seedDatabase() {
            const modulesSnapshot = await getDocs(collection(firestoreDB, "modules"));
            if (modulesSnapshot.empty) {
                console.log("Seeding Firestore with new module data...");
                for (const module of seedModules) {
                    await setDoc(doc(firestoreDB, "modules", module.id), module);
                }
            }
            if (!await getData('userData', 'profile')) {
                await addOrUpdate('userData', { key: 'profile', name: 'Cara', streak: 0, wordsLearned: [], accuracy: { correct: 0, total: 0 }, useGoogleTTS: false });
            }
        }

        // --- UI & STATE ---
        const allViews = {
            dashboard: document.getElementById('dashboard-view'),
            lesson: document.getElementById('lesson-view'),
            authorMode: document.getElementById('author-mode-view'),
            game: document.getElementById('game-view'),
        };
        const flashcardActivity = document.getElementById('flashcard-activity');
        let currentModule = null, currentPhraseIndex = 0, isFlipped = false, currentPhrase = null;

        function showView(viewName) {
            stopCurrentAudio();
            Object.values(allViews).forEach(v => v.classList.add('hidden'));
            allViews[viewName].classList.remove('hidden');
        }

        async function renderDashboard() {
            const modulesGrid = document.getElementById('modules-grid');
            const modulesSnapshot = await getDocs(collection(firestoreDB, "modules"));
            let modules = [];
            modulesSnapshot.forEach(doc => modules.push(doc.data()));
            
            modules.sort((a, b) => moduleOrder.indexOf(a.id) - moduleOrder.indexOf(b.id));

            modulesGrid.innerHTML = '';
            modules.forEach(module => {
                const card = document.createElement('div');
                card.className = 'bg-emerald-100 p-4 rounded-xl shadow-md text-center cursor-pointer hover:bg-emerald-200 transition';
                card.innerHTML = `<div class="text-4xl mb-2">${module.icon}</div><h3 class="font-bold">${module.title}</h3>`;
                card.addEventListener('click', () => startLesson(module.id));
                modulesGrid.appendChild(card);
            });
            
            const profile = await getData('userData', 'profile');
            document.getElementById('username-display').textContent = profile.name || 'Cara';
            document.getElementById('streak-days').textContent = profile.streak || 0;
            document.getElementById('words-learned').textContent = profile.wordsLearned?.length || 0;
            const acc = profile.accuracy;
            const accPercent = (acc && acc.total > 0) ? Math.round((acc.correct / acc.total) * 100) : 0;
            document.getElementById('accuracy-percent').textContent = `${accPercent}%`;

            await updateGameLockStatus();
            
            showView('dashboard');
        }

        // --- Game Lock Management ---
        async function updateGameLockStatus() {
            const profile = await getData('userData', 'profile');
            const wordsLearned = profile.wordsLearned?.length || 0;
            const isUnlocked = wordsLearned >= 20;

            const gameButtons = ['speed-match-btn', 'memory-grid-btn', 'fill-blanks-btn', 'listen-tap-btn', 'sentence-builder-btn'];
            
            gameButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                const container = btn.closest('.locked-game-container');
                
                if (isUnlocked) {
                    btn.classList.remove('locked-game');
                    container.querySelector('.lock-message').style.display = 'none';
                } else {
                    btn.classList.add('locked-game');
                    container.querySelector('.lock-message').style.display = 'block';
                }
            });
        }

        async function checkGameAccess() {
            const profile = await getData('userData', 'profile');
            const wordsLearned = profile.wordsLearned?.length || 0;
            
            if (wordsLearned < 20) {
                showMessage("Learn 20 words to unlock games");
                return false;
            }
            return true;
        }

        async function getLearnedPhrases() {
            const profile = await getData('userData', 'profile');
            const learnedIds = profile.wordsLearned || [];
            
            const modulesSnapshot = await getDocs(collection(firestoreDB, "modules"));
            let allPhrases = [];
            modulesSnapshot.forEach(doc => {
                const module = doc.data();
                const learnedPhrases = module.phrases.filter(p => learnedIds.includes(p.id));
                allPhrases.push(...learnedPhrases);
            });
            
            return allPhrases;
        }
        
        // --- LESSON LOGIC ---
        async function startLesson(moduleId) {
            stopCurrentAudio();
            
            const moduleDoc = await getDoc(doc(firestoreDB, "modules", moduleId));
            currentModule = moduleDoc.data();
            if (!currentModule || currentModule.phrases.length === 0) { 
                showMessage("This module has no phrases yet."); 
                return; 
            }
            
            const profile = await getData('userData', 'profile');
            const learnedIds = profile.wordsLearned || [];
            
            const unlearnedPhrases = currentModule.phrases.filter(p => !learnedIds.includes(p.id));
            const learnedPhrases = currentModule.phrases.filter(p => learnedIds.includes(p.id));
            
            const priorityPhrases = [];
            for (const phrase of learnedPhrases) {
                const tracking = await getData('cardTracking', phrase.id);
                if (tracking && tracking.againCount > 0) {
                    const priority = Math.max(1, tracking.againCount - tracking.gotItCount);
                    for (let i = 0; i < priority && priorityPhrases.length < 3; i++) {
                        priorityPhrases.push(phrase);
                    }
                }
            }
            
            let lessonPhrases = [];
            lessonPhrases.push(...unlearnedPhrases.slice(0, 5));
            
            if (lessonPhrases.length < 5) {
                const remaining = 5 - lessonPhrases.length;
                lessonPhrases.push(...priorityPhrases.slice(0, remaining));
            }
            
            if (lessonPhrases.length < 5) {
                const remaining = 5 - lessonPhrases.length;
                const availableLearned = learnedPhrases.filter(p => !priorityPhrases.includes(p));
                const shuffled = availableLearned.sort(() => 0.5 - Math.random());
                lessonPhrases.push(...shuffled.slice(0, remaining));
            }
            
            const usedInSession = new Set();
            currentModule.lessonPhrases = lessonPhrases.filter(phrase => {
                if (usedInSession.has(phrase.id)) return false;
                usedInSession.add(phrase.id);
                return true;
            });

            document.getElementById('lesson-title').textContent = currentModule.title;
            showView('lesson');
            document.getElementById('app-header').classList.add('hidden');

            currentPhraseIndex = 0;
            nextActivity();
        }

        async function endLesson() {
            stopCurrentAudio();
            document.getElementById('app-header').classList.remove('hidden');
            showTrivia();
        }
        
        async function showTrivia() {
            const triviaSnapshot = await getDocs(collection(firestoreDB, "trivia"));
            let karnatakaTrivia = [];
            triviaSnapshot.forEach(doc => karnatakaTrivia.push(doc.data()));
            if (karnatakaTrivia.length === 0) {
                console.warn("Trivia collection is empty. Skipping trivia modal.");
                renderDashboard();
                return;
            }
            const trivia = karnatakaTrivia[Math.floor(Math.random() * karnatakaTrivia.length)];
            const modal = document.getElementById('trivia-modal');
            modal.innerHTML = `<div class="bg-white p-6 rounded-lg shadow-xl w-96 text-center"><h3 class="text-lg font-bold mb-2">Did you know?</h3><p class="mb-2">${trivia.q}</p><p class="font-bold text-emerald-600 mb-4">${trivia.answer}</p><button id="trivia-close" class="bg-emerald-500 text-white font-bold py-2 px-4 rounded">Continue</button></div>`;
            modal.classList.remove('hidden');
            modal.querySelector('#trivia-close').addEventListener('click', () => { 
                stopCurrentAudio();
                modal.classList.add('hidden'); 
                renderDashboard(); 
            });
        }

        function nextActivity() {
            stopCurrentAudio();
            
            if (currentPhraseIndex >= currentModule.lessonPhrases.length) { 
                endLesson(); 
                return; 
            }
            showFlashcard();
            currentPhraseIndex++;
        }

        async function updateProgress(wasCorrect, phraseId) {
            stopCurrentAudio();
            
            const profile = await getData('userData', 'profile');
            profile.accuracy.total++;
            
            let tracking = await getData('cardTracking', phraseId) || { 
                phraseId, 
                againCount: 0, 
                gotItCount: 0, 
                lastSeen: new Date().toISOString() 
            };
            
            if (wasCorrect) {
                profile.accuracy.correct++;
                
                const wasAlreadyLearned = profile.wordsLearned.includes(phraseId);
                tracking.gotItCount++;
                
                if (!wasAlreadyLearned) {
                    profile.wordsLearned.push(phraseId);
                    console.log(`Added word ${phraseId} to learned words. Total learned: ${profile.wordsLearned.length}`);
                }
                
                let srsData = await getData('srs', phraseId) || { phraseId, step: 0 };
                srsData.step++;
                const reviewIntervals = [1, 3, 7];
                const interval = reviewIntervals[Math.min(srsData.step - 1, reviewIntervals.length - 1)];
                const nextReviewDate = new Date();
                nextReviewDate.setDate(nextReviewDate.getDate() + interval);
                srsData.nextReview = nextReviewDate.toISOString().split('T')[0];
                srsData.lastReviewed = new Date().toISOString().split('T')[0];
                await addOrUpdate('srs', srsData);
            } else {
                tracking.againCount++;
            }
            
            tracking.lastSeen = new Date().toISOString();
            await addOrUpdate('cardTracking', tracking);
            await addOrUpdate('userData', profile);
        }
        
        // --- CANVAS RENDERING (IMPROVED WITH DIRTY FLAG) ---
        const flashcardCanvas = document.getElementById('flashcard-canvas');
        const flashcardCtx = flashcardCanvas.getContext('2d');
        let flashcardDirty = true;
        
        function resizeCanvas(canvas) {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
            flashcardDirty = true;
        }
        
        function drawFlashcard(phrase, showKannada) {
            if (!flashcardDirty) return;
            
            const canvas = flashcardCanvas; 
            const rect = canvas.getBoundingClientRect();
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            resizeCanvas(canvas);
            
            const ctx = flashcardCtx; 
            ctx.fillStyle = '#FFFBEB'; 
            ctx.fillRect(0, 0, rect.width, rect.height); 
            ctx.fillStyle = '#10B981'; 
            ctx.textAlign = 'center';
            
            if (showKannada) { 
                ctx.font = 'bold 32px Inter'; 
                ctx.fillText(phrase.kn, rect.width / 2, rect.height / 2 - 20); 
                ctx.font = '20px Inter'; 
                ctx.fillStyle = '#6B7280'; 
                ctx.fillText(phrase.translit, rect.width / 2, rect.height / 2 + 20); 
            } else { 
                ctx.font = 'bold 32px Inter'; 
                ctx.fillText(phrase.en, rect.width / 2, rect.height / 2); 
            }
            
            ctx.font = '14px Inter'; 
            ctx.fillStyle = '#9CA3AF'; 
            ctx.fillText('Tap to flip', rect.width / 2, rect.height - 20);
            
            flashcardDirty = false;
        }

        function showFlashcard() { 
            flashcardActivity.classList.remove('hidden'); 
            isFlipped = false; 
            currentPhrase = currentModule.lessonPhrases[currentPhraseIndex]; 
            flashcardDirty = true;
            drawFlashcard(currentPhrase, isFlipped);
            
            document.getElementById('replay-audio-btn').classList.add('hidden');
        }
        
        // --- TTS WITH IMPROVED ERROR HANDLING ---
        async function speakTTS(phrase) {
            const profile = await getData('userData', 'profile');
            
            if (!profile.useGoogleTTS || !GOOGLE_API_KEY) {
                if (profile.useGoogleTTS) console.warn("Google API Key not set. Using browser's default TTS.");
                
                // Fallback to browser TTS
                try {
                    const utterance = new SpeechSynthesisUtterance(phrase.kn);
                    utterance.lang = 'kn-IN';
                    utterance.onerror = (event) => {
                        console.error('Speech synthesis error:', event.error);
                        showMessage('Text-to-speech failed. Please try again.');
                    };
                    window.speechSynthesis.speak(utterance);
                } catch (error) {
                    console.error('Browser TTS error:', error);
                    showMessage('Text-to-speech not available.');
                }
                return;
            }

            const ttsApiUrl = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${GOOGLE_API_KEY}`;
            const requestBody = {
                input: { text: phrase.kn },
                voice: { languageCode: 'kn-IN', name: 'kn-IN-Wavenet-A' },
                audioConfig: { audioEncoding: 'MP3' }
            };

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch(ttsApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    if (response.status === 429) {
                        throw new Error('API quota exceeded. Please try again later.');
                    } else if (response.status === 403) {
                        throw new Error('API key invalid or restricted.');
                    } else {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                }
                
                const data = await response.json();
                
                if (data.audioContent) {
                    stopCurrentAudio();
                    currentAudio = new Audio("data:audio/mp3;base64," + data.audioContent);
                    
                    const audioPromise = currentAudio.play();
                    audioPromises.add({ audio: currentAudio });
                    
                    audioPromise.then(() => {
                        audioPromises.delete({ audio: currentAudio });
                    }).catch(e => {
                        console.error("Google TTS audio playback failed:", e);
                        audioPromises.delete({ audio: currentAudio });
                        // Fallback to browser TTS
                        const utterance = new SpeechSynthesisUtterance(phrase.kn);
                        utterance.lang = 'kn-IN';
                        window.speechSynthesis.speak(utterance);
                    });
                } else {
                    throw new Error('No audio content received from API');
                }
                
            } catch (error) {
                console.error("Google TTS Error:", error);
                
                if (error.name === 'AbortError') {
                    showMessage("Request timed out. Please check your connection.");
                } else {
                    showMessage(`TTS failed: ${error.message}. Using fallback voice.`);
                }
                
                // Fallback to browser TTS
                try {
                    const utterance = new SpeechSynthesisUtterance(phrase.kn);
                    utterance.lang = 'kn-IN';
                    window.speechSynthesis.speak(utterance);
                } catch (fallbackError) {
                    console.error('Fallback TTS also failed:', fallbackError);
                    showMessage('All text-to-speech options failed.');
                }
            }
        }

        function speak(phrase) {
            stopCurrentAudio();
            
            if (phrase && phrase.audioData) {
                currentAudio = new Audio(phrase.audioData);
                
                const audioPromise = currentAudio.play();
                audioPromises.add({ audio: currentAudio });
                
                audioPromise.then(() => {
                    audioPromises.delete({ audio: currentAudio });
                }).catch(e => {
                    console.error("Audio playback failed:", e.name, e.message);
                    audioPromises.delete({ audio: currentAudio });
                    
                    if (e.name === 'NotSupportedError' || e.name === 'NotAllowedError') {
                        console.warn("Recorded audio failed, falling back to TTS.");
                        showMessage("Couldn't play recording, using text-to-speech.");
                        speakTTS(phrase);
                    }
                });
            } else {
                speakTTS(phrase);
            }
        }
        
        let audioUnlocked = false;
        function unlockAudioContext() {
            if (audioUnlocked) return;
            const sound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
            sound.play().then(() => {
                audioUnlocked = true;
                document.body.removeEventListener('click', unlockAudioContext);
                console.log("Audio unlocked.");
            }).catch(e => console.error("Audio unlock failed.", e));
        }
        document.body.addEventListener('click', unlockAudioContext);

        // --- GAME LOGIC (IMPROVED CLEANUP) ---
        const gameContainer = document.getElementById('game-container');
        let activeGame = null, gameLoopId = null, timerIntervalId = null, gameState = {};
        let canvasDirty = true;
        
        function exitGame() { 
            stopCurrentAudio();
            
            // Comprehensive cleanup
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            if (timerIntervalId) {
                clearInterval(timerIntervalId);
                timerIntervalId = null;
            }
            
            // Clear game state
            activeGame = null;
            gameState = {};
            canvasDirty = true;
            
            // Remove any game event listeners
            const gameCanvas = gameContainer.querySelector('#game-canvas');
            if (gameCanvas) {
                gameCanvas.replaceWith(gameCanvas.cloneNode(true));
            }
            
            renderDashboard(); 
        }
        
        class Card { 
            constructor(id, text, type, x, y, width, height) { 
                this.id = id; 
                this.text = text; 
                this.type = type; 
                this.x = x; 
                this.y = y; 
                this.width = width; 
                this.height = height; 
                this.state = 'hidden'; 
                this.selected = false; 
            } 
            
            draw(ctx) { 
                ctx.strokeStyle = this.selected ? '#4F46E5' : '#34D399'; 
                ctx.lineWidth = this.selected ? 5 : 3; 
                ctx.fillStyle = this.state === 'matched' ? '#A7F3D0' : (this.state === 'revealed' ? '#FFFBEB' : '#10B981'); 
                
                ctx.beginPath(); 
                const r = 10; 
                ctx.moveTo(this.x + r, this.y); 
                ctx.arcTo(this.x + this.width, this.y, this.x + this.width, this.y + this.height, r); 
                ctx.arcTo(this.x + this.width, this.y + this.height, this.x, this.y + this.height, r); 
                ctx.arcTo(this.x, this.y + this.height, this.x, this.y, r); 
                ctx.arcTo(this.x, this.y, this.x + this.width, this.y, r); 
                ctx.closePath(); 
                ctx.fill(); 
                ctx.stroke(); 
                
                if (this.state === 'revealed' || this.state === 'matched') { 
                    ctx.fillStyle = '#1F2937'; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.font = 'bold 16px Inter'; 
                    ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2); 
                } 
            } 
            
            isClicked(mx, my) { 
                return mx > this.x && mx < this.x + this.width && my > this.y && my < this.y + this.height; 
            } 
        }
        
        async function getPhrasesForGame(count) { 
            const learnedPhrases = await getLearnedPhrases();
            if (learnedPhrases.length < count) { 
                showMessage(`You need at least ${count} learned phrases to play.`); 
                return []; 
            } 
            return learnedPhrases.sort(() => 0.5 - Math.random()).slice(0, count); 
        }
        
        function gameLoop() { 
            const gameCanvas = gameContainer.querySelector('#game-canvas'); 
            if (!gameCanvas || !canvasDirty) {
                if (!gameState.gameOver && activeGame) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
                return;
            }
            
            const gameCtx = gameCanvas.getContext('2d'); 
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height); 
            
            if (gameState.cards) {
                gameState.cards.forEach(card => card.draw(gameCtx));
            }
            
            canvasDirty = false;
            
            if (!gameState.gameOver && activeGame) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }
        
        function updateTimer() { 
            gameState.timeLeft--; 
            const timerElement = gameContainer.querySelector('#game-timer');
            if (timerElement) {
                timerElement.textContent = `Time: ${gameState.timeLeft}s`;
            }
            
            if (gameState.timeLeft <= 0) { 
                gameState.gameOver = true; 
                clearInterval(timerIntervalId); 
                timerIntervalId = null;
                showMessage(`Time's up! Final Score: ${gameState.score}`); 
                setTimeout(exitGame, 2000);
            } 
        }
        
        function checkWinCondition() { 
            const allMatched = gameState.cards.every(c => c.state === 'matched'); 
            if (allMatched) { 
                if (timerIntervalId) {
                    clearInterval(timerIntervalId); 
                    timerIntervalId = null;
                }
                gameState.gameOver = true; 
                gameState.score += gameState.timeLeft || 0; 
                setTimeout(() => { 
                    showMessage(`You won! Final Score: ${gameState.score}`); 
                    setTimeout(exitGame, 2000);
                }, 500); 
            } 
        }
        
        function setupGameCanvas() { 
            const timerHTML = activeGame !== 'MemoryGrid' ? `<div id="game-timer">Time: ${gameState.timeLeft}s</div>` : ''; 
            gameContainer.innerHTML = `<div class="flex justify-around mb-2 text-lg font-bold">${timerHTML}<div id="game-score">Score: 0</div></div><canvas id="game-canvas" class="w-full h-96 rounded-lg bg-gray-100 cursor-pointer"></canvas>`; 
            
            const gameCanvas = gameContainer.querySelector('#game-canvas'); 
            
            // Responsive canvas setup
            function resizeGameCanvas() {
                const rect = gameCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                gameCanvas.width = rect.width * dpr;
                gameCanvas.height = rect.height * dpr;
                gameCanvas.getContext('2d').scale(dpr, dpr);
                canvasDirty = true;
            }
            
            window.addEventListener('resize', resizeGameCanvas);
            
            requestAnimationFrame(() => { 
                resizeGameCanvas();
                
                gameCanvas.addEventListener('click', (e) => { 
                    if (activeGame === 'SpeedMatch' || activeGame === 'MemoryGrid') {
                        handleCardGameClick(e);
                    }
                }); 
                
                if (activeGame === 'SpeedMatch' || activeGame === 'MemoryGrid') { 
                    const phrases = gameState.phrases; 
                    let cardData = []; 
                    phrases.forEach(p => { 
                        cardData.push({ id: p.id, text: p.en, type: 'en' }); 
                        cardData.push({ id: p.id, text: p.kn, type: 'kn' }); 
                    }); 
                    cardData.sort(() => 0.5 - Math.random()); 
                    
                    const cols = 4, rows = 4; 
                    const rect = gameCanvas.getBoundingClientRect();
                    const cardWidth = (rect.width - (cols + 1) * 10) / cols; 
                    const cardHeight = (rect.height - (rows + 1) * 10) / rows; 
                    
                    for (let i = 0; i < cardData.length; i++) { 
                        const row = Math.floor(i / cols), col = i % cols; 
                        const x = col * (cardWidth + 10) + 10, y = row * (cardHeight + 10) + 10; 
                        const card = new Card(cardData[i].id, cardData[i].text, cardData[i].type, x, y, cardWidth, cardHeight); 
                        if (activeGame === 'SpeedMatch') card.state = 'revealed'; 
                        gameState.cards.push(card); 
                    } 
                    
                    canvasDirty = true;
                    gameLoopId = requestAnimationFrame(gameLoop); 
                } 
            }); 
        }
        
        async function startSpeedMatchGame() { 
            if (!await checkGameAccess()) return;
            stopCurrentAudio();
            
            const phrases = await getPhrasesForGame(8); 
            if (phrases.length === 0) return; 
            
            activeGame = 'SpeedMatch'; 
            document.getElementById('game-title').textContent = 'Speed Match'; 
            showView('game'); 
            
            gameState = { cards: [], selected: [], score: 0, timeLeft: 30, gameOver: false, phrases: phrases }; 
            setupGameCanvas(); 
            timerIntervalId = setInterval(updateTimer, 1000); 
        }
        
        async function startMemoryGridGame() { 
            if (!await checkGameAccess()) return;
            stopCurrentAudio();
            
            const phrases = await getPhrasesForGame(8); 
            if (phrases.length === 0) return; 
            
            activeGame = 'MemoryGrid'; 
            document.getElementById('game-title').textContent = 'Memory Grid'; 
            showView('game'); 
            
            gameState = { cards: [], selected: [], score: 0, gameOver: false, phrases: phrases }; 
            setupGameCanvas(); 
        }
        
        function handleCardGameClick(e) { 
            stopCurrentAudio();
            
            if (gameState.gameOver || gameState.selected.length === 2) return; 
            
            const gameCanvas = gameContainer.querySelector('#game-canvas'); 
            const rect = gameCanvas.getBoundingClientRect(); 
            const mouseX = e.clientX - rect.left; 
            const mouseY = e.clientY - rect.top; 
            
            for (const card of gameState.cards) { 
                if (card.state !== 'matched' && !card.selected && card.isClicked(mouseX, mouseY)) { 
                    if (activeGame === 'MemoryGrid' && card.state === 'hidden') { 
                        card.state = 'revealed'; 
                    } 
                    card.selected = true; 
                    gameState.selected.push(card); 
                    canvasDirty = true;
                    break; 
                } 
            } 
            
            if (gameState.selected.length === 2) { 
                const [c1, c2] = gameState.selected; 
                if (c1.id === c2.id && c1.type !== c2.type) { 
                    c1.state = 'matched'; 
                    c2.state = 'matched'; 
                    gameState.score += 10; 
                    const scoreElement = gameContainer.querySelector('#game-score');
                    if (scoreElement) {
                        scoreElement.textContent = `Score: ${gameState.score}`;
                    }
                    gameState.selected = []; 
                    canvasDirty = true;
                    checkWinCondition(); 
                } else { 
                    setTimeout(() => { 
                        if (activeGame === 'MemoryGrid') { 
                            c1.state = 'hidden'; 
                            c2.state = 'hidden'; 
                        } 
                        c1.selected = false; 
                        c2.selected = false; 
                        gameState.selected = []; 
                        canvasDirty = true;
                    }, 500); 
                } 
            } 
        }
        
        let newGameState = {};
        
        async function startFillBlanksGame() { 
            if (!await checkGameAccess()) return;
            stopCurrentAudio();
            
            activeGame = 'FillBlanks'; 
            document.getElementById('game-title').textContent = 'Fill in the Blanks'; 
            showView('game'); 
            
            const allPhrases = await getPhrasesForGame(100); 
            const suitablePhrases = allPhrases.filter(p => p.kn.split(' ').length > 1); 
            if (suitablePhrases.length < 5) { 
                showMessage("Not enough multi-word phrases unlocked. Learn more words to play this game."); 
                exitGame(); 
                return; 
            } 
            
            newGameState = { questions: suitablePhrases.slice(0, 5), currentQuestionIndex: 0, score: 0 }; 
            renderFillBlanksQuestion(); 
        }
        
        async function renderFillBlanksQuestion() { 
            if (newGameState.currentQuestionIndex >= newGameState.questions.length) { 
                showMessage(`Game Over! Your score: ${newGameState.score} / 5`); 
                setTimeout(exitGame, 2000);
                return; 
            } 
            
            const questionData = newGameState.questions[newGameState.currentQuestionIndex]; 
            const words = questionData.kn.split(' '); 
            const blankIndex = Math.floor(Math.random() * words.length); 
            const correctWord = words[blankIndex]; 
            words[blankIndex] = '______'; 
            const questionText = words.join(' '); 
            
            const allPhrases = await getLearnedPhrases(); 
            const wrongWords = [...new Set(allPhrases.flatMap(p => p.kn.split(' ')))].filter(w => w !== correctWord).sort(() => 0.5 - Math.random()).slice(0, 3); 
            const options = [correctWord, ...wrongWords].sort(() => 0.5 - Math.random()); 
            
            gameContainer.innerHTML = `<div class="text-center mb-4"><p class="text-lg text-gray-600">${questionData.en}</p><p class="text-2xl font-semibold my-4">${questionText}</p></div><div id="fill-options" class="grid grid-cols-2 gap-3">${options.map(opt => `<button class="game-option p-4 bg-gray-100 hover:bg-gray-200 rounded-lg border-2 border-transparent shadow-sm text-lg">${opt}</button>`).join('')}</div><div class="mt-4 text-center font-bold text-lg">Score: ${newGameState.score} | Question: ${newGameState.currentQuestionIndex + 1} / 5</div>`; 
            
            document.querySelectorAll('.game-option').forEach(btn => btn.onclick = (e) => handleFillBlanksAnswer(e, correctWord)); 
        }
        
        function handleFillBlanksAnswer(e, correctWord) { 
            stopCurrentAudio();
            
            const isCorrect = e.target.textContent === correctWord; 
            if (isCorrect) { 
                newGameState.score++; 
                e.target.classList.add('correct-answer'); 
            } else { 
                e.target.classList.add('incorrect-answer'); 
            } 
            
            document.querySelectorAll('.game-option').forEach(btn => { 
                btn.disabled = true; 
                if(btn.textContent === correctWord) btn.classList.add('correct-answer'); 
            }); 
            
            newGameState.currentQuestionIndex++; 
            setTimeout(renderFillBlanksQuestion, 1500); 
        }
        
        async function startListenTapGame() { 
            if (!await checkGameAccess()) return;
            stopCurrentAudio();
            
            activeGame = 'ListenTap'; 
            document.getElementById('game-title').textContent = 'Listen & Tap'; 
            showView('game'); 
            
            const phrases = await getPhrasesForGame(20); 
            if (phrases.length < 4) return; 
            
            newGameState = { questions: phrases.slice(0, 5), currentQuestionIndex: 0, score: 0 }; 
            renderListenTapQuestion(); 
        }
        
        async function renderListenTapQuestion() { 
            if (newGameState.currentQuestionIndex >= newGameState.questions.length) { 
                showMessage(`Game Over! Your score: ${newGameState.score} / 5`); 
                setTimeout(exitGame, 2000);
                return; 
            } 
            
            const correctPhrase = newGameState.questions[newGameState.currentQuestionIndex]; 
            const allPhrases = await getLearnedPhrases(); 
            const wrongOptions = allPhrases.filter(p => p.id !== correctPhrase.id).sort(() => 0.5 - Math.random()).slice(0, 3); 
            const options = [correctPhrase, ...wrongOptions].sort(() => 0.5 - Math.random()); 
            
            gameContainer.innerHTML = `<div class="text-center mb-6"><button id="play-audio-btn" class="p-4 bg-blue-500 text-white rounded-full shadow-lg text-3xl">‚ñ∂Ô∏è</button><p class="mt-2 text-gray-600">Tap to hear the phrase</p></div><div id="listen-options" class="grid grid-cols-1 gap-3">${options.map(opt => `<button class="game-option p-4 bg-gray-100 hover:bg-gray-200 rounded-lg border-2 border-transparent shadow-sm text-lg">${opt.en}</button>`).join('')}</div><div class="mt-4 text-center font-bold text-lg">Score: ${newGameState.score} | Question: ${newGameState.currentQuestionIndex + 1} / 5</div>`; 
            
            document.getElementById('play-audio-btn').onclick = () => speak(correctPhrase); 
            document.querySelectorAll('.game-option').forEach(btn => btn.onclick = (e) => handleListenTapAnswer(e, correctPhrase)); 
        }
        
        function handleListenTapAnswer(e, correctPhrase) { 
            stopCurrentAudio();
            
            const isCorrect = e.target.textContent === correctPhrase.en; 
            if (isCorrect) { 
                newGameState.score++; 
                e.target.classList.add('correct-answer'); 
            } else { 
                e.target.classList.add('incorrect-answer'); 
            } 
            
            document.querySelectorAll('.game-option').forEach(btn => { 
                btn.disabled = true; 
                if(btn.textContent === correctPhrase.en) btn.classList.add('correct-answer'); 
            }); 
            
            newGameState.currentQuestionIndex++; 
            setTimeout(renderListenTapQuestion, 1500); 
        }
        
        async function startSentenceBuilderGame() { 
            if (!await checkGameAccess()) return;
            stopCurrentAudio();
            
            activeGame = 'SentenceBuilder'; 
            document.getElementById('game-title').textContent = 'Sentence Builder'; 
            showView('game'); 
            
            const phrases = await getPhrasesForGame(20); 
            const longPhrases = phrases.filter(p => p.translit && p.translit.split('-').length > 2); 
            if (longPhrases.length < 5) { 
                showMessage("Not enough complex phrases to play."); 
                exitGame(); 
                return; 
            } 
            
            newGameState = { questions: longPhrases.slice(0, 5), currentQuestionIndex: 0, score: 0 }; 
            renderSentenceBuilderQuestion(); 
        }
        
        function renderSentenceBuilderQuestion() { 
            if (newGameState.currentQuestionIndex >= newGameState.questions.length) { 
                showMessage(`Game Over! Your score: ${newGameState.score} / 5`); 
                setTimeout(exitGame, 2000);
                return; 
            } 
            
            const phrase = newGameState.questions[newGameState.currentQuestionIndex]; 
            const words = phrase.translit.split('-'); 
            const shuffledWords = [...words].sort(() => 0.5 - Math.random()); 
            
            gameContainer.innerHTML = `<div class="text-center mb-4"><p class="text-lg text-gray-600">Translate this sentence:</p><p class="text-2xl font-semibold my-2">"${phrase.en}"</p></div><div id="sentence-answer" class="p-4 bg-gray-200 rounded-lg min-h-[50px] mb-4 text-center text-xl font-semibold"></div><div id="word-bank" class="flex flex-wrap justify-center gap-2">${shuffledWords.map(word => `<button class="word-tile p-2 bg-indigo-100 rounded-md shadow-sm">${word}</button>`).join('')}</div><div class="mt-6 flex justify-center gap-4"><button id="check-sentence-btn" class="bg-green-500 text-white font-bold py-2 px-6 rounded-lg">Check</button><button id="clear-sentence-btn" class="bg-gray-400 text-white font-bold py-2 px-6 rounded-lg">Clear</button></div><div class="mt-4 text-center font-bold text-lg">Score: ${newGameState.score} | Question: ${newGameState.currentQuestionIndex + 1} / 5</div>`; 
            
            const answerArea = document.getElementById('sentence-answer'); 
            const wordBank = document.getElementById('word-bank'); 
            
            wordBank.addEventListener('click', (e) => { 
                if (e.target.classList.contains('word-tile')) { 
                    stopCurrentAudio();
                    answerArea.textContent += (answerArea.textContent ? '-' : '') + e.target.textContent; 
                    e.target.style.visibility = 'hidden'; 
                } 
            }); 
            
            document.getElementById('clear-sentence-btn').onclick = () => { 
                stopCurrentAudio();
                answerArea.textContent = ''; 
                wordBank.querySelectorAll('.word-tile').forEach(tile => tile.style.visibility = 'visible'); 
            }; 
            
            document.getElementById('check-sentence-btn').onclick = () => { 
                stopCurrentAudio();
                const userAnswer = answerArea.textContent.toLowerCase().replace(/-/g, ''); 
                const correctAnswer = phrase.translit.toLowerCase().replace(/-/g, ''); 
                const isCorrect = userAnswer === correctAnswer; 
                
                if (isCorrect) { 
                    newGameState.score++; 
                    answerArea.classList.add('correct-answer'); 
                } else { 
                    answerArea.classList.add('incorrect-answer'); 
                } 
                
                newGameState.currentQuestionIndex++; 
                setTimeout(renderSentenceBuilderQuestion, 1500); 
            }; 
        }
        
        let triviaState = {};
        
        async function startTriviaGame() { 
            stopCurrentAudio();
            
            activeGame = 'Trivia'; 
            document.getElementById('game-title').textContent = 'Karnataka Trivia'; 
            showView('game'); 
            
            const triviaSnapshot = await getDocs(collection(firestoreDB, "trivia")); 
            let karnatakaTrivia = []; 
            triviaSnapshot.forEach(doc => karnatakaTrivia.push(doc.data())); 
            
            if (karnatakaTrivia.length < 3) { 
                showMessage("Not enough trivia questions to play yet. Need at least 3."); 
                exitGame(); 
                return; 
            } 
            
            const shuffledTrivia = [...karnatakaTrivia].sort(() => 0.5 - Math.random()); 
            triviaState = { questions: shuffledTrivia.slice(0, 3), currentQuestionIndex: 0, score: 0 }; 
            renderTriviaQuestion(); 
        }
        
        function renderTriviaQuestion() { 
            if (triviaState.currentQuestionIndex >= triviaState.questions.length) { 
                showMessage(`Trivia Complete! Your score: ${triviaState.score} / ${triviaState.questions.length}`); 
                setTimeout(exitGame, 2000);
                return; 
            } 
            
            const questionData = triviaState.questions[triviaState.currentQuestionIndex]; 
            
            gameContainer.innerHTML = `<div class="text-center mb-4"><p class="text-lg font-semibold">${questionData.q}</p></div><div id="trivia-options" class="grid grid-cols-1 md:grid-cols-2 gap-3">${questionData.options.map(opt => `<button class="trivia-option p-4 bg-gray-100 hover:bg-gray-200 rounded-lg border-2 border-transparent shadow-sm text-lg">${opt}</button>`).join('')}</div><div class="mt-4 text-center font-bold text-lg">Score: ${triviaState.score}</div>`; 
            
            document.querySelectorAll('.trivia-option').forEach(button => { 
                button.addEventListener('click', handleTriviaAnswer); 
            }); 
        }
        
        function handleTriviaAnswer(e) { 
            stopCurrentAudio();
            
            const selectedOption = e.target; 
            const questionData = triviaState.questions[triviaState.currentQuestionIndex]; 
            const isCorrect = selectedOption.textContent === questionData.answer; 
            
            document.querySelectorAll('.trivia-option').forEach(btn => { 
                btn.disabled = true; 
                if (btn.textContent === questionData.answer) { 
                    btn.classList.add('correct-answer'); 
                } 
            }); 
            
            if (isCorrect) { 
                triviaState.score++; 
                selectedOption.classList.add('correct-answer'); 
            } else { 
                selectedOption.classList.add('incorrect-answer'); 
            } 
            
            triviaState.currentQuestionIndex++; 
            setTimeout(renderTriviaQuestion, 1500); 
        }
        
        // === AUTHOR MODE & MODALS (IMPROVED MEDIARECORDER HANDLING) ===
        let mediaRecorder = null;
        let audioChunks = [];
        let activeStream = null;

        function stopActiveMicrophone() {
            if (activeStream) {
                activeStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Microphone track stopped');
                });
                activeStream = null;
            }
        }

        async function renderAuthorEditor() { 
            const editor = document.getElementById('author-mode-view'); 
            const profile = await getData('userData', 'profile');
            const isTtsEnabled = profile.useGoogleTTS || false;

            editor.innerHTML = `<div class="flex justify-between items-center mb-4"><h2 class="text-2xl font-bold">Author Mode</h2><button id="exit-author-mode-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Exit</button></div>
                                <div class="mb-6 border-b pb-4">
                                    <h3 class="text-xl font-bold mb-2">Settings</h3>
                                    <div class="flex items-center justify-between">
                                        <label for="google-tts-toggle" class="font-semibold">Enable Google Text-To-Speech</label>
                                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                            <input type="checkbox" name="google-tts-toggle" id="google-tts-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" ${isTtsEnabled ? 'checked' : ''}/>
                                            <label for="google-tts-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                        </div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4"><button id="import-json-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Import JSON</button><input type="file" id="json-file-input" class="hidden" accept=".json"><button id="export-json-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">Export JSON</button></div><h3 class="text-xl font-bold mb-2">Edit Modules & Phrases</h3><div id="author-content-editor" class="space-y-4"></div><button id="add-module-btn" class="mt-4 bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg">Add New Module</button><div class="mt-6 border-t pt-4"><h3 class="text-xl font-bold mb-2 text-red-600">Danger Zone</h3><button id="reset-progress-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Reset All Progress</button></div>`; 
            
            const contentEditor = document.getElementById('author-content-editor'); 
            const modulesSnapshot = await getDocs(collection(firestoreDB, "modules"));
            let modules = [];
            modulesSnapshot.forEach(doc => modules.push(doc.data()));
            modules.sort((a, b) => moduleOrder.indexOf(a.id) - moduleOrder.indexOf(b.id));

            contentEditor.innerHTML = ''; 
            modules.forEach(module => { 
                const container = document.createElement('div'); 
                container.className = 'p-4 border rounded-lg'; 
                container.innerHTML = `<div class="flex justify-between items-center mb-2"><input class="text-xl font-bold border-b-2" value="${module.title}" data-module-id="${module.id}" data-field="title" /><input class="w-12 text-center border-b-2" value="${module.icon}" data-module-id="${module.id}" data-field="icon" /></div><div class="phrases-container space-y-2">${(module.phrases || []).map((p, i) => `<div id="author-phrase-${module.id}-${i}" class="grid grid-cols-6 gap-2 items-center p-2 bg-gray-50 rounded"><input class="border rounded px-2 py-1" placeholder="English" value="${p.en}" data-module-id="${module.id}" data-phrase-index="${i}" data-field="en" /><input class="border rounded px-2 py-1" placeholder="Kannada" value="${p.kn}" data-module-id="${module.id}" data-phrase-index="${i}" data-field="kn" /><input class="border rounded px-2 py-1 col-span-2" placeholder="Transliteration" value="${p.translit || ''}" data-module-id="${module.id}" data-phrase-index="${i}" data-field="translit" />${p.audioData ? `<audio controls class="w-24 h-8" src="${p.audioData}"></audio>` : `<div class="w-24 h-8 audio-placeholder"></div>`}<div class="flex items-center gap-2"><button class="text-xl" data-record-btn data-module-id="${module.id}" data-phrase-index="${i}">üé§</button><button class="text-red-500 hover:font-bold" data-delete-btn data-module-id="${module.id}" data-phrase-index="${i}">X</button></div></div>`).join('')}</div><button class="mt-2 text-blue-500 hover:font-bold" data-add-phrase-btn data-module-id="${module.id}">Add Phrase</button>`; 
                contentEditor.appendChild(container); 
            }); 
            
            contentEditor.querySelectorAll('input').forEach(input => input.addEventListener('change', handleAuthorInputChange)); 
            contentEditor.querySelectorAll('[data-add-phrase-btn]').forEach(btn => btn.addEventListener('click', () => addPhrase(btn.dataset.moduleId))); 
            contentEditor.querySelectorAll('[data-delete-btn]').forEach(btn => btn.addEventListener('click', () => deletePhrase(btn.dataset.moduleId, btn.dataset.phraseIndex))); 
            contentEditor.querySelectorAll('[data-record-btn]').forEach(btn => btn.addEventListener('click', (e) => toggleRecording(e.currentTarget, btn.dataset.moduleId, btn.dataset.phraseIndex))); 
            
            document.getElementById('exit-author-mode-btn').addEventListener('click', () => {
                stopCurrentAudio();
                
                // Comprehensive cleanup for author mode
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.onstop = null; 
                    mediaRecorder.stop();
                }
                stopActiveMicrophone();
                
                // Reset recording state
                mediaRecorder = null;
                audioChunks = [];
                
                renderDashboard();
            }); 

            document.getElementById('add-module-btn').addEventListener('click', async () => { 
                stopCurrentAudio();
                const title = await showPrompt("Enter new module title:"); 
                if (title) { 
                    const newModule = { id: title.toLowerCase().replace(/\s+/g, '-'), title, icon: '‚ú®', phrases: [] }; 
                    await setDoc(doc(firestoreDB, "modules", newModule.id), newModule); 
                    renderAuthorEditor(); 
                } 
            }); 
            
            document.getElementById('export-json-btn').addEventListener('click', () => {
                stopCurrentAudio();
                exportToJson();
            }); 
            
            const jsonFileInput = document.getElementById('json-file-input'); 
            document.getElementById('import-json-btn').addEventListener('click', () => {
                stopCurrentAudio();
                jsonFileInput.click();
            }); 
            
            jsonFileInput.addEventListener('change', (e) => { 
                stopCurrentAudio();
                const file = e.target.files[0]; 
                if (!file) return; 
                
                const reader = new FileReader(); 
                reader.onload = async (re) => { 
                    try { 
                        const data = JSON.parse(re.target.result); 
                        if (data.modules && Array.isArray(data.modules)) { 
                            for (const module of data.modules) await setDoc(doc(firestoreDB, "modules", module.id), module); 
                        } 
                        if (data.userData) await addOrUpdate('userData', data.userData); 
                        showMessage('Data imported successfully!'); 
                        renderAuthorEditor(); 
                    } catch (err) { 
                        showMessage('Error importing JSON: ' + err.message); 
                    } 
                }; 
                reader.readAsText(file); 
            }); 
            
            document.getElementById('reset-progress-btn').addEventListener('click', () => {
                stopCurrentAudio();
                resetAllProgress();
            }); 
            
            document.getElementById('google-tts-toggle').addEventListener('change', async (e) => {
                const profile = await getData('userData', 'profile');
                profile.useGoogleTTS = e.target.checked;
                await addOrUpdate('userData', profile);
            });
        }
        
        async function toggleRecording(button, moduleId, phraseIndex) {
            stopCurrentAudio();
            
            // If we are currently recording, stop it
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
                console.log("Stopping recording...");
                return;
            }

            try {
                // Ensure any previous stream is fully stopped
                stopActiveMicrophone();

                // Request microphone access with specific constraints
                activeStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    } 
                });
                
                console.log("Recording started");
                
                // Create MediaRecorder with optimal settings
                const options = { mimeType: 'audio/webm; codecs=opus' };
                mediaRecorder = MediaRecorder.isTypeSupported(options.mimeType) 
                    ? new MediaRecorder(activeStream, options) 
                    : new MediaRecorder(activeStream);
                
                // Reset audio chunks array
                audioChunks = [];
                
                mediaRecorder.addEventListener("dataavailable", event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                });

                // Critical: Handle the stop event properly
                mediaRecorder.onstop = async () => {
                    console.log("MediaRecorder stopped, processing audio...");

                    // Immediately stop microphone and reset UI
                    stopActiveMicrophone();
                    button.innerHTML = 'üé§';
                    button.classList.remove("recording", "text-red-500");
                    button.disabled = false;

                    if (audioChunks.length === 0) {
                        showMessage("No audio data was recorded.");
                        return;
                    }

                    const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
                    console.log(`Audio blob created. Size: ${audioBlob.size} bytes, Type: ${audioBlob.type}`);
                    
                    if (audioBlob.size < 1000) {
                         showMessage("Recording was too short or empty. Please try again.");
                         return;
                    }
                    
                    showMessage('Uploading audio...');

                    try {
                        const timestamp = Date.now();
                        const fileName = `audio/${moduleId}_phrase_${phraseIndex}_${timestamp}.webm`;
                        const storageRef = ref(storage, fileName);
                        
                        console.log(`Uploading to Firebase Storage: ${fileName}`);
                        
                        // Upload with retry logic
                        let uploadAttempts = 0;
                        const maxAttempts = 3;
                        
                        while (uploadAttempts < maxAttempts) {
                            try {
                                await uploadBytes(storageRef, audioBlob);
                                console.log('Upload successful');
                                break;
                            } catch (uploadError) {
                                uploadAttempts++;
                                if (uploadAttempts >= maxAttempts) throw uploadError;
                                console.warn(`Upload attempt ${uploadAttempts} failed, retrying...`);
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        }
                        
                        const downloadURL = await getDownloadURL(storageRef);
                        console.log('Download URL obtained:', downloadURL);
                        
                        // Update Firestore
                        const moduleDocRef = doc(firestoreDB, "modules", moduleId);
                        const moduleDoc = await getDoc(moduleDocRef);
                        if (!moduleDoc.exists()) throw new Error(`Module ${moduleId} not found`);
                        
                        const moduleData = moduleDoc.data();
                        if (!moduleData.phrases?.[phraseIndex]) throw new Error(`Phrase at index ${phraseIndex} not found`);
                        
                        moduleData.phrases[phraseIndex].audioData = downloadURL;
                        
                        await setDoc(moduleDocRef, moduleData);
                        console.log('Firestore document updated successfully');
                        
                        // Update UI
                        const phraseElement = document.getElementById(`author-phrase-${moduleId}-${phraseIndex}`);
                        if (phraseElement) {
                            const audioContainer = phraseElement.querySelector('.audio-placeholder, audio');
                            if (audioContainer) {
                                const newAudio = document.createElement('audio');
                                newAudio.controls = true;
                                newAudio.className = 'w-24 h-8';
                                newAudio.src = downloadURL;
                                audioContainer.replaceWith(newAudio);
                            }
                        }
                        
                        document.getElementById('message-modal').classList.add('hidden');
                        showMessage('Audio saved successfully!');
                        setTimeout(() => {
                            document.getElementById('message-modal').classList.add('hidden');
                        }, 2000);
                        
                    } catch (uploadError) {
                        console.error("Firebase upload/update error:", uploadError);
                        document.getElementById('message-modal').classList.add('hidden');
                        
                        let errorMessage = 'Upload failed: ';
                        if (uploadError.code === 'storage/unauthorized') {
                            errorMessage += 'Permission denied. Check Firebase storage rules.';
                        } else if (uploadError.code === 'storage/quota-exceeded') {
                            errorMessage += 'Storage quota exceeded.';
                        } else if (uploadError.message.includes('CORS')) {
                            errorMessage += 'CORS error. Check Firebase storage CORS configuration.';
                        } else {
                            errorMessage += uploadError.message;
                        }
                        
                        showMessage(errorMessage);
                    } finally {
                        // Clean up regardless of success/failure
                        audioChunks = [];
                        mediaRecorder = null;
                    }
                };

                // Start recording and update UI
                mediaRecorder.start();
                button.classList.add("recording", "text-red-500");
                button.innerHTML = '‚óºÔ∏è';
                
            } catch (err) {
                console.error("Error accessing microphone:", err);
                let errorMessage = "Microphone access failed: ";
                
                if (err.name === 'NotAllowedError') {
                    errorMessage += "Permission denied. Please allow microphone access.";
                } else if (err.name === 'NotFoundError') {
                    errorMessage += "No microphone found.";
                } else if (err.name === 'NotReadableError') {
                    errorMessage += "Microphone is being used by another application.";
                } else {
                    errorMessage += err.message;
                }
                
                showMessage(errorMessage);
                stopActiveMicrophone();
                button.innerHTML = 'üé§';
                button.classList.remove("recording", "text-red-500");
            }
        }

        async function handleAuthorInputChange(e) { 
            stopCurrentAudio();
            const { moduleId, field, phraseIndex } = e.target.dataset; 
            const moduleDoc = await getDoc(doc(firestoreDB, "modules", moduleId)); 
            const module = moduleDoc.data(); 
            
            if (phraseIndex) {
                module.phrases[parseInt(phraseIndex)][field] = e.target.value; 
            } else {
                module[field] = e.target.value; 
            }
            
            await setDoc(doc(firestoreDB, "modules", moduleId), module); 
        }
        
        async function addPhrase(moduleId) { 
            stopCurrentAudio();
            const moduleDoc = await getDoc(doc(firestoreDB, "modules", moduleId)); 
            const module = moduleDoc.data(); 
            const newId = module.phrases.length > 0 ? Math.max(...module.phrases.map(p => p.id)) + 1 : Date.now(); 
            module.phrases.push({ id: newId, en: '', kn: '', translit: '' }); 
            await setDoc(doc(firestoreDB, "modules", moduleId), module); 
            renderAuthorEditor(); 
        }
        
        async function deletePhrase(moduleId, phraseIndex) { 
            stopCurrentAudio();
            const confirmed = await showConfirm('Are you sure?'); 
            if (confirmed) { 
                const moduleDoc = await getDoc(doc(firestoreDB, "modules", moduleId)); 
                const module = moduleDoc.data(); 
                module.phrases.splice(phraseIndex, 1); 
                await setDoc(doc(firestoreDB, "modules", moduleId), module); 
                renderAuthorEditor(); 
            } 
        }
        
        async function exportToJson() { 
            const modulesSnapshot = await getDocs(collection(firestoreDB, "modules")); 
            let modules = []; 
            modulesSnapshot.forEach(doc => modules.push(doc.data())); 
            const exportData = { modules, userData: await getData('userData', 'profile') }; 
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2)); 
            const a = document.createElement('a'); 
            a.href = dataStr; 
            a.download = "kbb_export.json"; 
            a.click(); 
        }
        
        async function resetAllProgress() { 
            const confirmed = await showConfirm("Are you sure you want to reset ALL progress? This cannot be undone."); 
            if (confirmed) { 
                await clearStore('userData'); 
                await clearStore('srs'); 
                await clearStore('progressLog'); 
                await clearStore('cardTracking'); 
                await clearStore('profilePictures');
                await addOrUpdate('userData', { key: 'profile', name: 'Cara', streak: 0, wordsLearned: [], accuracy: { correct: 0, total: 0 }, useGoogleTTS: false }); 
                showMessage("All progress has been reset."); 
                renderDashboard(); 
            } 
        }
        
        function showMessage(text) { 
            stopCurrentAudio();
            const modal = document.getElementById('message-modal'); 
            modal.innerHTML = `<div class="bg-white p-6 rounded-lg shadow-xl w-80"><p class="mb-4 text-center">${text}</p><button class="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded">OK</button></div>`; 
            modal.classList.remove('hidden'); 
            modal.querySelector('button').addEventListener('click', () => modal.classList.add('hidden')); 
        }
        
        function showConfirm(message) { 
            stopCurrentAudio();
            return new Promise(resolve => { 
                const modal = document.getElementById('confirm-modal'); 
                modal.innerHTML = `<div class="bg-white p-6 rounded-lg shadow-xl w-80"><p class="mb-4 text-center">${message}</p><div class="flex justify-end space-x-4"><button id="confirm-no-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded">No</button><button id="confirm-yes-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded">Yes</button></div></div>`; 
                modal.classList.remove('hidden'); 
                modal.querySelector('#confirm-yes-btn').addEventListener('click', () => { modal.classList.add('hidden'); resolve(true); }); 
                modal.querySelector('#confirm-no-btn').addEventListener('click', () => { modal.classList.add('hidden'); resolve(false); }); 
            }); 
        }
        
        function showPrompt(text) { 
            stopCurrentAudio();
            return new Promise(resolve => { 
                const modal = document.getElementById('prompt-modal'); 
                modal.innerHTML = `<div class="bg-white p-6 rounded-lg shadow-xl w-96"><p class="mb-4 text-center">${text}</p><input id="prompt-input" class="w-full p-2 border rounded mb-4"><div class="flex justify-end space-x-2"><button id="prompt-cancel" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded">Cancel</button><button id="prompt-ok" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded">OK</button></div></div>`; 
                modal.classList.remove('hidden'); 
                const input = modal.querySelector('#prompt-input'); 
                input.focus(); 
                modal.querySelector('#prompt-ok').addEventListener('click', () => { modal.classList.add('hidden'); resolve(input.value); }); 
                modal.querySelector('#prompt-cancel').addEventListener('click', () => { modal.classList.add('hidden'); resolve(null); }); 
                input.addEventListener('keyup', (e) => { if (e.key === 'Enter') modal.querySelector('#prompt-ok').click(); }); 
            }); 
        }

        // --- PROFILE PICTURE MANAGEMENT (MOVED TO INDEXEDDB) ---
        async function loadProfilePicture() {
            try {
                const profilePicData = await getData('profilePictures', 'main');
                if (profilePicData && profilePicData.data) {
                    document.getElementById('profile-pic').src = profilePicData.data;
                }
            } catch (error) {
                console.log('No profile picture found in IndexedDB');
            }
        }

        async function saveProfilePicture(imageData) {
            try {
                await addOrUpdate('profilePictures', { id: 'main', data: imageData });
                console.log('Profile picture saved to IndexedDB');
            } catch (error) {
                console.error('Failed to save profile picture:', error);
            }
        }

        async function initApp() {
            await initDB();
            await seedDatabase();
            await loadProfilePicture();
            await renderDashboard();
            
            document.getElementById('loading-indicator').style.display = 'none';

            // Add resize listener for responsive canvas handling
            window.addEventListener('resize', () => {
                flashcardDirty = true;
                canvasDirty = true;
                
                if (currentPhrase && isFlipped !== undefined) {
                    drawFlashcard(currentPhrase, isFlipped);
                }
            });

            document.getElementById('exit-game-btn').addEventListener('click', exitGame);
            
            document.getElementById('speed-match-btn').addEventListener('click', startSpeedMatchGame);
            document.getElementById('memory-grid-btn').addEventListener('click', startMemoryGridGame);
            document.getElementById('trivia-game-btn').addEventListener('click', startTriviaGame);
            document.getElementById('fill-blanks-btn').addEventListener('click', startFillBlanksGame);
            document.getElementById('listen-tap-btn').addEventListener('click', startListenTapGame);
            document.getElementById('sentence-builder-btn').addEventListener('click', startSentenceBuilderGame);
            
            document.getElementById('exit-lesson-btn').addEventListener('click', () => {
                stopCurrentAudio();
                document.getElementById('app-header').classList.remove('hidden');
                renderDashboard();
            });
            
            flashcardCanvas.addEventListener('click', () => { 
                isFlipped = !isFlipped; 
                flashcardDirty = true;
                drawFlashcard(currentPhrase, isFlipped); 
                
                if (isFlipped) {
                    speak(currentPhrase);
                    document.getElementById('replay-audio-btn').classList.remove('hidden');
                } else {
                    stopCurrentAudio();
                    document.getElementById('replay-audio-btn').classList.add('hidden');
                }
            });
            
            document.getElementById('replay-audio-btn').addEventListener('click', () => {
                if (isFlipped && currentPhrase) {
                    speak(currentPhrase);
                }
            });
            
            document.getElementById('flashcard-right').addEventListener('click', () => { 
                updateProgress(true, currentPhrase.id); 
                document.getElementById('replay-audio-btn').classList.add('hidden');
                nextActivity(); 
            });
            
            document.getElementById('flashcard-wrong').addEventListener('click', () => { 
                updateProgress(false, currentPhrase.id); 
                document.getElementById('replay-audio-btn').classList.add('hidden');
                nextActivity(); 
            });
            
            document.getElementById('author-mode-btn').addEventListener('click', () => {
                stopCurrentAudio();
                const modal = document.getElementById('passcode-modal');
                modal.innerHTML = `<div class="bg-white p-8 rounded-lg shadow-xl w-80"><h3 class="text-xl font-bold mb-4 text-center">Enter Passcode</h3><input type="password" id="passcode-input" maxlength="4" class="w-full p-3 text-center text-2xl tracking-[1em] border-2 rounded-lg mb-2"><p id="passcode-error" class="text-red-500 h-5 text-center mb-4"></p><button id="passcode-submit" class="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg">Enter</button><button id="passcode-close" class="w-full bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg mt-2">Cancel</button></div>`;
                modal.classList.remove('hidden');
                const input = modal.querySelector('#passcode-input');
                input.focus();
                modal.querySelector('#passcode-close').addEventListener('click', () => modal.classList.add('hidden'));
                modal.querySelector('#passcode-submit').addEventListener('click', () => { 
                    if (input.value === '1104') { 
                        modal.classList.add('hidden'); 
                        showView('authorMode'); 
                        renderAuthorEditor(); 
                    } else { 
                        modal.querySelector('#passcode-error').textContent = 'Incorrect passcode.'; 
                    } 
                });
                input.addEventListener('keyup', (e) => { if (e.key === 'Enter') modal.querySelector('#passcode-submit').click(); });
            });
            
            const profilePic = document.getElementById('profile-pic');
            const profilePicInput = document.getElementById('profile-pic-input');
            
            document.getElementById('user-profile').addEventListener('click', async (e) => {
                if (e.target.id === 'username-display') {
                    stopCurrentAudio();
                    const newName = await showPrompt("What's your name?");
                    if (newName) { 
                        const profile = await getData('userData', 'profile'); 
                        profile.name = newName; 
                        await addOrUpdate('userData', profile); 
                        document.getElementById('username-display').textContent = newName; 
                    }
                } else {
                    profilePicInput.click();
                }
            });
            
            profilePicInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) { 
                    const reader = new FileReader(); 
                    reader.onload = async (re) => { 
                        const imageData = re.target.result; 
                        await saveProfilePicture(imageData);
                        profilePic.src = imageData; 
                    }; 
                    reader.readAsDataURL(file); 
                }
            });
        }

        initApp();
    </script>
</body>
</html>

<!-- Summary of All Fixed Issues:
‚úÖ Critical Audio Management Bug: Implemented comprehensive stopCurrentAudio() function with promise tracking and proper cleanup
‚úÖ Memory Leak in MediaRecorder: Added proper MediaRecorder cleanup with stream management and audio chunks reset
‚úÖ Race Condition in Audio Playbook: Implemented audio promise tracking and proper cancellation
‚úÖ Firebase Storage CORS Issue: Added comprehensive error handling with specific CORS error messages and retry logic
‚úÖ IndexedDB Transaction Deadlock Risk: Implemented transaction queuing system with proper error handling
‚úÖ Canvas Rendering Performance: Added dirty flag pattern for both flashcard and game canvases
‚úÖ Missing Error Handling for TTS API: Added comprehensive error handling with fallbacks, timeout, and quota management
‚úÖ Profile Picture Storage Inconsistency: Moved profile pictures from localStorage to IndexedDB
‚úÖ Game State Cleanup Bug: Implemented comprehensive cleanup in exitGame() with proper timer and animation frame management
‚úÖ Responsive Design Issues: Added responsive CSS and canvas resizing with device pixel ratio support -->